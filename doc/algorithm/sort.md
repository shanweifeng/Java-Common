## [排序算法](https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md)
* 稳定排序: 数据集合排序后，两个相同元素的相对位置没有改变。

* 不稳定排序: 数据集合排序后，两个相同元素的相对位置发生改变。

## 冒泡排序
> 对于要排序的数据，从上到下一次比较两个相邻的数并加以调整，将最大的数向下移动，较小的数向上毛起。即每一堂依次比较相邻的两个数据元素，将较小的数放在左边，循环进行同样的操作，知道全部待排序的数据元素排完。 时间复杂度为O(n^2)
>> 稳定排序

## 选择排序
> 每次从待排序列表中查找剩余最大或最小的数据，与当前未排序列表的第一个交换。时间复杂度为O(n^2)
>> 不稳定排序？（如果存在两个元素相等，而仅判断小于或大于的情况就可能会出现不稳定情况）

## 插入排序
> 从第一个元素开始，该元素可以认为已经被排序；取出第一个未排序元素存放在临时变量中，在已经排序的元素列表中从后往前扫描，逐一比较；如果临时元素小于已排序元素，将该元素移动到下一个位置；重复比较已排序位置。时间复杂度为O(n^2)
>> 稳定排序

### 快速排序
> 采用分治思想。在数据集中选择一个元素作为"基准"，将小于基准的数据移动到一边，大于基准的数据移动到另一边。分别对两个子集进行前面的操作，直到两边只剩下一个元素为止。从一边找出符合要求的数据与基准数据交换，然后再从另一边查找，直到排序完成。时间复杂度为O(nlogn)。
>> 不稳定排序

### 归并排序
> 采用分治思想。将数据集拆分为子集，直到子集为一个元素或两个元素的直接有序集合，然后在将各个有序的子集合并成一个有序的且全部排好顺序的集合。时间复杂度为O(nlogn)。
>> 稳定排序

### 希尔排序
> 按照不同步长对元素进行插入排序，当元素无序时步长最大，这个时候排序的元素最少，速度很快；当元素基本有序后，步长很小，插入排序对于有序的序列效率很高。
>> 不稳定排序 

### 基数排序
> 基数排序不需要进行记录关键字之间的比较。是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。即多关键字排序就是有多个优先级不同的关键字，比如成绩的排序，如果两个总分相同则语文高的拍前面，依次类推。需要较多的存储空间，基于分别排序、分别收集。
>> 稳定排序

### 堆排序
> 选择排序的一种。堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点，是完全二叉树。
>> 不稳定排序

### 计数排序
> 用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。
>> 不稳定排序

### 桶排序
> 将一组长度为N的待排序关键字划分为M个子区间，然后基于某种映射函数将数据映射到M个子区间，这里需要保证子区间的数据范围没有交叉(即前一个的最小值大于后一个的最大值)。然后给每个子区间进行比较排序。映射函数的确定与数据本省的特点有很大关系。
>> 稳定排序