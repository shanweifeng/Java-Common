## [分布性一致算法：Raft算法](https://juejin.im/entry/58aba36cac502e0069781b83)
```text
状态机保证每个服务器上面的日志都是以相同顺序存放的，这样在服务器故障恢复后状态机能根据日志及时正确的恢复服务器。
```

* 实际系统中的一致性算法通常具有以下属性：
```text
* 它们确保在所有非拜占庭条件下(包括网络延迟、分区和数据包丢失、重复和乱序)的安全性(不会返回不正确的结果).
* 只要任何大多数(过半)服务器都可以运行，并且可以互相通信和与客户通信，一致性算法就可用。因此，五台服务器的典型集群可以容忍任何两台服务器的故障。假设服务器突然宕机，他们可以稍后从状态恢复并重新加入集群。
* 它们不依赖于时序来确保日志的一致性：错误的时钟和极端消息延迟在最坏的情况下会导致可用性问题
* 在通常情况下，只要集群的大部分(过半服务器)已经响应了单轮远程过程调用，命令就可以完成；少数(一半以下)慢服务器不会影响整个系统性能。
```

* Paxos存在的问题
```text
* Paxos非常难以理解
* 它不能为构建实际的实现提供良好的基础？
```

* Raft一致性算法：
> 算法设计的目标
```text
* 必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作
* 必须在任何情况下都是安全的并且在典型的应用条件下是可用的
* 在正常情况下是高效的
* 必须保证能够被大多数人容易的理解
* 必须能够让人形成直观的认识，这样系统的构建者才能够在视线中进行扩展
```

> Raft算法可分为：leader选举、日志复制、安全性和成员变更
```text
* Leader 选举：当前leader宕机时，一个新的leader必须被选举出来
* 日志复制：Leader必须从客户端接收日志条目然后复制到集群中的其他节点，并且强制要求其他节点的日志和自己的保持一致。
* 安全性：Raft中安全性的关键是状态机的安全性：如果有任何的服务器节点已经应用了一个特定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一条不同的指令。
```

* Raft服务器节点三个状态
```text
* leader： Leader处理所有的客户端请求(如果一个客户端和follower通信，follower会将请求重定向给leader)
* follower：
* candidate：
```

```text
* 如果不同日志中的两个条目拥有相同的索引号和任期号，那么他们存储了相同的指令。
* 如果不同日志中的两个条目拥有相同的索引号和任期号，那么他们之前的所有日志条目也都相同。
```

```text
一个日志索引对应一个日志条目
```
> 如果leader崩溃了 有可能出现以下情况
```text
follower的日志有可能缺少一些在新leader中有的日志条目，也有可能拥有一些新leader没有的日志条目，或者两者同时发生。
```

* Raft的定时(timing)和可用性
```text
安全性不能依赖定时：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生错误的结果。但是，可用性(系统能够即时响应客户端)不可避免的要依赖于定时。例如当有服务器崩溃时，消息交换的时间就会比正常情况下长，candidate将不会等待太长的时间来赢得选举；没有一个稳定的leader，Raft将无法工作。

广播时间 << 选举超时时间 << 平均故障间隔时间
广播时间：是一个服务器并行地发送RPCs给集群中所有的其他服务器并接收到响应的平均时间
选举超时时间：
平均故障间隔时间：就是对于一台服务器而言，两次故障间隔时间的平均值。
```

* 配置变更
```text
新的服务器在开始时可能没有存储任何的日志条目
集群的leader可能不是新配置中的一员
被移除的服务器可能会扰乱集群
```

* 日志压缩
```text

```