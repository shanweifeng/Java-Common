## VM类加载机制
[参见理解Java类加载机制](/doc/jdk/classLoader/理解Java类加载机制.md)

> VM把描述类的数据从Class文件加载到内存，并对数据进行校验、(前面还有准备)转换解析和初始化，最终形成可以被VM直接使用的Java类型，这就是VM的类加载机制。

> 类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但却能为Java应用程序提供高度的灵活性，Java中天生可以动态扩展的语言特性就是依赖运行期间动态加载和动态链接这个特点实现的。例如Java多态特性，就是在运行时再指定其实际的实现，动态代理等。

### 类加载的时机
> 类的声明周期:加载Loading、 连接(验证Verification、准备Preparation、解析Resolution)、初始化Initialization、使用Using、卸载Unloading，Java类从进入VM到删除的整个过程。
>> 加载、验证、准备、初始化、卸载这几个阶段顺序是确定的，类的加载过程必须安装这种顺序按部就班地**开始**，而解析阶段则不一定：他在某些情况下可以在初始化之后在开始，这是为了支持Java语言的运行时绑定(也称动态绑定或晚期绑定)。**这里是按部就班的"开始",而不是按部就班地"进行"或"完成"，这些阶段通常都是相互交叉的混合式进行，通常会在一个阶段执行的过程中调用或激活另外一个阶段**

> VM规范中没有对加载进行强制约束，具体交给VM实现来自由把握，VM规范严格规定了有且 只有四种情况必须立即对类进行"初始化"(加载、验证、准备要在此之前):
>> * 1、遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是:使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候，以及调用一个类的静态方法的时候。
>> * 2、使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
>> * 3、当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化
>> * 4、当VM启动时，用户需要指定一个要执行的主类(包含main方法)，VM会先初始化这个主类

> 上面4中触发类进行初始化话的场景的行为称为堆一个类进行主动引用。除此之外所有引用类的方式，都不会触发初始化，称为被动引用：
>> * 1、通过子类引用父类的静态字段，不会导致子类初始化(只有直接定义这个地段的类才会被初始化-即静态代码块的执行)
>> * 2、通过数组定义来引用类，不会触发此类的初始化(这里会创建一个数组但不会初始化目标类)
>> * 3、常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

> 接口的加载过程与类家在过程稍有不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块"static{}"来输出初始化信息的，二接口中不能使用"static{}"语句块，但编译器仍然会为接口生成"<clinit>()"类构造器，用于初始化接口中所定义的成员变量。接口与类真正有所区别的是前面讲述的四种"有且仅有"需要开始初始化场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都初始化完成了，只有在真正用到父接口的时候(如引用接口中定义的常量)才会初始化。

### 类加载的过程
* 加载(loading)
> 是"类加载"(Class Loading)过程的一个阶段。在加载阶段，VM需要完成以下三件事情：
> * 1、通过一个类的全限定名来获取定义此类的二进制字节流。
> * 2、将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。
> * 3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。
> VM规范的几点要求不具体，因此VM实现与具体应用的灵活度相当大。例如第一点没有确定从哪里获取以及怎样获取。这样就早就了很多厉害的技术
>> * 从ZIP包中读取，最终成为日后JAR、EAR、WAR格式的基础。
>> * 从网络中获取，这种场景最典型的应用就是Applet
>> * 运行时计算生成，这种场景使用的最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成*$Proxy的代理类的二进制字节流。
>> * 由其它文件生成，典型场景:JSP应用
>> * 从数据库中读取，这种场景相对少见，有些中间件服务器(如SAP Netweaver)可选择把程序安装到数据库中来完成程序代码在集群间的分发。
>> * ...
> 相对于类加载过程的其他阶段，加载阶段(准确的说是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为家在阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。<p>
> 加载阶段完成后，VM外部的二进制字节流就按照VM所需的格式存储在方法区之中，方法区中的数据存储格式由VM实现自定义。然后在Java堆中实例化一个java.lang.Class类对象，这个对象将作为程序访问方法区中的这些类性数据的外部接口。加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些加载加载阶段中进行的动作仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

* 验证
> 是连接阶段的第一步，这一阶段的目的是为了确保Class文件字节流中包含的信息符合当前VM的要求，并且不会危害VM自省的安全。<p>
>> Java语言本身是相对安全的语言，使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、讲一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做，编译器将拒绝执行。但在字节码的语言层面上，这些代码无法做到的事情都是可以实现的，至少语义上可以表达出来。VM如果不检查输入的字节流，对其完全信任，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证时VM对自身保护的一项重要工作。
> VM对验证没有强制要求或说明，不同的编码堆类验证的实现可能会不同，但大致会完成这几个阶段:文件格式验证、元数据验证、字节码验证和符号引用验证。
>> * 文件格式验证<p>
>>> 1、是否以魔数0xCAFEBABE开头<p>
>>> 2、主、次版本号是否在当前VM处理范围之内<p>
>>> 3、常量池中的常量中是否有不被支持的常量类型(检查常量tag标志)<p>
>>> 4、指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量<p>
>>> 5、CONSTANT_Utf8_info类型常量中是否有不符合UTF8编码的数据<p>
>>> 6、Class文件中各部分及文件本身是否有被删除或附加的其他信息<p>
>>> 7、...<p>
>> 上面验证点只是一少部分，验证阶段的主要目的是保证输入的字节流能正确地解析并存储与方法区之内，格式上符合描述一个Java类型信息的要求。这阶段的验证时基于字节流进行的，经过验证阶段后字节流才会进入内存的方法区中存储，所以后面是哪个验证阶段全部都是及与方法区的存储结构进行的。
>> * 元数据验证
>>> 是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，验证点如下<p>
>>> 1、这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)<p>
>>> 2、这个类的父类是否继承了不被允许继承的类(被final修饰的类)<p>
>>> 3、如果这个类不是抽象类，是否实现了父类或接口之中要求实现的所有方法<p>
>>> 4、类中的字段、方法是否与父类产生了矛盾(如覆盖了父类的final字段或者出现不符合规则的方法重载，例如方法参数都一致但返回值类型却不同等)<p>
>>> 5、...<p>
>>> 这一阶段主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息
>> * 字节码验证
>>> 字节码验证 是整个验证阶段中最复杂的一个阶段，主要工作时进行数据流控制和控制流分析。在第二阶段对元素居信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析。这阶段的任务是保证被校验类的方法在运行时不会做出危害VM安全的行为:
>>> * 1、保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈中放置了一个int类型的数据，使用时却按照long类型来加载入本地变量中。
>>> * 2、保证跳转指令不会跳转到方法体以外的字节码指令上。
>>> * 3、保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的。但是把父类对象赋值给子类数据类型甚至把对象赋值给它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。
>>> * 4、。。。

>> 如果一个类方法体的字节码没有通过字节码验证，肯定是有问题的；但如果一个方法提通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证中进行了大量的检查，也不能保证一定安全。(这里涉及到离散数学中一个很著名的问题"Halting Problem"：通俗的讲就是通过程序去校验程序逻辑是无法做到绝对准确的-不能通过程序准确地检查出程序是否能在有限的时间之内结束运行)。<p>
>>> 字节码数据流验证高度复杂，为了避免过度消耗时间在此阶段，JDK1.6之后的Javac编译器中进行了一项优化，给方法体的Code属性的属性表添加了一项名为"StackMapTable"的属性，这项属性描述了方法体中所有的基本款(Basic Block,按照控制流拆分的代码块)开始时本地变量表和操作栈应有的状态，这可以将字节码验证的类型推导为类型检查从而节省一些时间。当然这个属性也可能存在错误或被篡改的可能，所以是否存在可能的恶意篡改了Code属性的同事，也生成响应的StackMapTable属性来骗过VM的类型校验是VM实现时值得思考的问题。
>>>> JDK1.6的HotSpot VM中提供了-XX:UseSplitVerifier选项来关闭掉这项优化，或者是用参数-XX:FailOverToOleVerfifier要求在类型校验失败时退回到旧的类型推导方式进行校验。而在JDK1.7之后，对于主版本号大于50的Class文件，使用类型检查来完成数据流分析校验则是唯一选择，不允许在退回到类型推导的校验方式。

>> * 符号引用验证
>>> 这一阶段的校验发生在VM将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段--解析阶段发生。符号引用验证可以看做是对类自身以外(常量池中的各种符号引用)的信息进行匹配性的校验，通常需要校验以下内容:
>>> * 1、符号引用中通过字符串描述的全限定名是否能找到对应的类
>>> * 2、在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
>>> * 3、符号引用中的类、字段和方法的访问性(private、protected、public、default)是否可被当前类访问
>>> * 4、。。。

>> 目的是确保解析动作能正常执行，如果无法通过符号引用验证，将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。

> 验证阶段是一个非常重要的但比一定是必要的阶段。如果所运行的全部代码(包括第三方包)都已经被反复使用和验证过，在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短VM类加载时间。

* 准备
> 是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都在方法区中进行分配。这个阶段中进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次这里所说的初始值"通常情况下"是数据类型为零值，因为此时尚未执行任何Java方法，而赋值的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法中，所以赋值的动作将在初始化阶段才会被执行。<p>
如果类字段被final修饰。那在准备阶段变量就会被初始化为指定值。以下是基本数据类型的零值

|数据类型|零值|
|--------|--------|
|int|0|
|long|0L|
|short|(short)0|
|char|'\u0000'|
|byte|(byte)0|
|boolean|false|
|float|0.0f|
|double|0.0d|
|reference|null|

* 解析
> 是VM将常量池内的符号引用替换为直接引用的过程，在Class文件中CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量。
> * 符号引用(Symbolic References)：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用域VM实现的内存布局无关，引用的目标并不一定已经加载到内存中。
> * 直接引用(Direct References)：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与VM实现的内存布局相关的，同一个符号引用在不同VM实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。<p>

> VM规范中并未规定解析阶段发生的具体时间，只要求在执行anewarray、checkcast、getfield、getstatic、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对这些指令所使用的符号引用进行解析。所以VM实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析还是等到一个符号引用将要被使用前才去解析它。

> 对同一个符号引用进行多次解析请求，VM可能会对第一次解析的结果进行缓存(在运行时常量池中记录直接引用，并把常量标识为已解析状态)从而避免解析动作重复进行。不管是否存在多次解析动作，VM都需要保证后面的解析结果与第一次的解析结果一致。

> 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用，分别对应常量池的CONSTANT_Class_info、CONSTANT_Fielfref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型
>> * 类或接口的解析
>>> 假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，则VM完成整个解析的过程需要包括以下3个步骤：
>>>> * 1、如果C不是一个数组类型，那么虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于无数据验证、字节码验证的需要，有将可能触发其他相关类的加载动作，例如加载这个类的父类或实现接口。一单这个加载过程出现任何异常，解析过程就宣告失败。、
>>>> * 2、如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符回事类似"[Ljava.lang.Integer]"的形式，则将会按照第一点的规则加载数组元素。如果N的描述符如前面所假设的形式，需要加载的元素类型就是"java.lang.Integer",接着由VM生成一个代表此数组唯独和元素的数组对象。
>>>> * 3、如果上面的步骤没有出现任何异常，那么C在VM中实际上已经成为一个有效的类或接口了，但在解析完成之前还需要进行符号引用验证，确认C是否具备对D的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。

>> * 字段解析
>>> 解析一个为被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个字段或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或借款用C表示，VM规范要求按照如下步骤堆C进行后续字段的搜索：
>>> * 1、如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
>>> * 2、否则，如果在C中实现了接口，将会按照继承关系从上往下地柜搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述都与目标相匹配的字段，返回这个字段引用，over。
>>> * 3、否则，如果C不是java.lang.Object的话，将会按照继承关系从上往下地柜搜索其父类，如果在父类中包含了简单名称与字段描述符都与目标相匹配的字段，则返回引用，over。
>>> * 4、否则查找失败，抛出java.lang.NoSuchFieldError异常。
>> 在实际应用中，如果字段来源模糊，则在编译是会提示"The field is ambiguous"，并会拒绝编译代码。

>> * 类方法解析
>>> 类方法解析的第一步骤与字段解析一样，也是需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个类。VM将会按照如下步骤进行后续的类方法搜索：
>>> * 1、类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是接口，直接抛出java.lang.IncompatibleClassChangeError异常
>>> * 2、如果在类方法中发现class_index是方法，在类C中查找是否有简单名称与描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束
>>> * 3、否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，over
>>> * 4、否则，在类C实现的接口列表及其父接口中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在，说明类C是一个抽象类，这时候类查找结束，抛出java.lang.AbstractMethodError异常。(接口方法在类中没有具体实现，则说明当前类为抽象类)
>>> * 5、否则查找失败，抛出java.lang.NoSuchFieldError异常。

>> * 接口方法解析
>>> 先解析出接口方法表的class_index项中索引的方法所诉的类或借款的符号引用，如果解析成功，使用C表示这个接口，然后进行后续的接口方法搜索
>>> * 1、如果在接口方法表中发现class_index中的索引C是个类而不是接口，直接抛出java.lang.IncompatibleClassChangeError异常
>>> * 2、否则，如果接口C中查找到有简单名称和描述符都与目标相匹配的方法，则返回这个方法的直接引用，over
>>> * 3、否则，在接口C的父类接口中递归查找，直到java.lang.Object(查找范围包括Object类)为止，如果有匹配的方法，返回其直接引用，over
>>> * 4、否则失败，抛出java.lang.NoSuchFieldError
>> 由于接口中所有方法都默认是public的，所以不存在访问权限问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常

* 初始化
> 初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由VM主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。

> 在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是铜鼓欧程序指定的助管计划去初始化类变量和其他资源，或者可以从另外一个角度来表达: 初始化阶段是执行类构造器<clinit>方法的过程。后面将会讲到<clinit>()方法的生成。这里先看<clinit>()方法执行过程中可能会影响程序运行行为的一些特点和细节：
>> * <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合并产生的，编译器收集的顺序是由于局在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。
>> * <clinit>()方法与类的构造函数(或者说实例构造器<init>()方法)不同，它不需要显示地调用父类构造器，VM会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在VM中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。
>> * 由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
>> * <clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。
>> * 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要限制性父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
>> * vm 会保证一个类的<clinit>()方法在多线程环境中被正确的加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有好事很长的操作，那就可能造成多个进程阻塞，实际应用中这种阻塞往往是很隐蔽的。

### 类加载器
> vm 设计团队把类加载阶段中的"通过一个类的全限定名来获取描述此类的二进制字节流"这个动作放到JavaVM外部去实现，以便让应用程序自己决定如何去获取所需要的类，。实现这个动作的代码模块被称为"类加载器".
>> 类加载器在类层次划分、OSGI、热部署、代码加密等领域有丰富应用
* 类与类加载器
> 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在JVM中的唯一性。通俗的讲：比较两个类是否"相等",只有在这两个类是由同一个类加载器(实例)加载的前提下才有意义，否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。<p>
这里的**相等**，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用了instanceof关键字做对象所属关系判定等情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。

* 双亲委派模型
> 站在VM角度讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader),这个类加载器使用C++语言实现(如果VM本身就是Java语言编写的例外)，是VM自省的一部分；另外一种就是所有其他的类加载器，这些类加载器都由Java预言实现，独立于VM之外，并且全部继承自抽象类java.lang.ClassLoader。

> 从开发人员的角度看，绝大部分Java程序都会使用到以下三种系统提供的类加载器：
> * 启动类加载器(Bootstrap ClassLoader):这个类加载器负责将存放在<JAVA_HOME>\lib目录中的、或被-Xbootclasspath参数所指定的路径中的，并且是VM识别的(仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到VM内存中。启动类无法被Java程序直接引用。

> * 扩展类加载器(Extension ClassLoader):这个加载器由sun.misc.Launcher.$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录中的、或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载起。

> *  应用程序类加载器(Application ClassLoader):这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，一般也称为系统类加载器。负责家在用户类路径(ClassPath)上指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

> 类加载器之间的继承关系(并非类之间的继承)被称为类加载器的双亲委派模型(Parents Delegation Model).双亲委派模型要求除了顶灯的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承(Inheritance)的关系来实现，而是都是用组合(Composition)关系来复用父加载器的代码。
>> 类加载器的双亲委派模型在JDK1.2期间被引入，但它不是一个强制性的约束模型，而是推荐的一种类加载器实现方式。

> 双亲委派模型的工作过程是:如果一个类加载器收到了类加载的请求，它寿险不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去加载，每一个层次的类加载器都如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围没有找到所需类)时，子类才会尝试自己去加载。

>> 双亲委派模型的这种优先层次关系，是的每个类最终都会是同一个类加载器来加载。实现双亲委派的代码都集中在在java.lang.ClassLoader的loadClass()方法中，代码逻辑是：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空择默认使用启动类加载器作为父加载器。如果父类加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

* 破坏双亲委派模型
> 双亲委派模型并不是一个强制性的约束模型，在Java中大部分的类加载器都遵循这个模型，但也有一些例外。目前主要出现三次较大规模的"被破坏"情况。

> 1、为了向前兼容。双亲委派模型在JDK1.2之后才被引入，在之前的jdk中没有，为了向前兼容，在java.lang.ClassLoader添加了一个新的protected方法findClass(),在此之前用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为VM在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass().JDK1.2之后不咋提倡用户再去覆盖loadClass()方法，而应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新的类加载器是符合双亲委派规则的。

> 2、自身缺陷。双亲委派很好的解决了各个类加载器的基础类的统一问题(越基础的类由越上层的加载器加载)。当出现启动类加载器需要调用用户代码时，如JNDI的SPI，引入了线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。(JDNI JDBC JCE JAXB JBI)

> 3、用户对程序动态性的追求导致。如代码替换(HotSwap)、模块热部署(Hot Deployment)等。

>> OSGI：每一个程序模块(OSGI中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle联通类加载器一起替换掉以实现代码的热替换。<p>
在OSGI环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构，当收到类加载请求时，OSGI将按照下面的顺序进行类搜索:<p>
1、将以java.*开头的类委派给父类加载器<p>
2、否则，将委派列表名单内的类委派给父类加载器加载。<p>
3、否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载<p>
4、否则，查找当前Bundle的ClassPath，使用自己的类加载器加载<p>
5、否则，查找类是否在自己的Fragment Bundle 中，如果在，则为拍给Fragment Bundle的类加载器加载<p>
6、否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载<p>
7、否则，类查找失败<p>

