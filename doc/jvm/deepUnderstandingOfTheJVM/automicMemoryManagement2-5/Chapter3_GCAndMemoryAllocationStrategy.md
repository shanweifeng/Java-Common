## 垃圾收集器和内存分配策略

> GC(Garbage Collection)需要完成的三件事：哪些内存需要回收、什么时候回收、如何回收？<p>
当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，需要对这些"自动化"的技术实施必要的监控和调节。<p>
在VM运行时数据区域中：虚拟机栈、本地方法栈、程序计数器都是随线程而生灭的，这部分内存消耗基本在类结构确定时就已经确定(尽管在运行期由JIT编译器进行一些优化，但大体上认为还是可知的)，因此这几个区域的内存分配和回收都具备确定性。而Java堆和方法区则不一样，接口的不同实现、方法的不同分支都只有在程序运行期间才会知道创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器所关注的就是这部分。
#### 对象追踪
* 引用计数算法(Reference Counting)
> 初始的算法是这样子的:给对象中添加一个引用计数器，每当有一个地方引用时，计数器值就+1，当引用失效时，计数器值就-1，任何时刻计数器都为0的对象就是不可能在被使用的.<p>

> 正常情况下，这种算法的效率还是很高的，但在对象循环引用之后，这种计数方式就会出现内存泄漏(内存回收不掉)。可以通过相互引用的代码在Java环境中执行，发现VM能够回收到循环引用的对象，这说明JVM使用的不是计数器算算法。

* 根搜索算法(GC Roots Tracing)
> 在主流的商用程序语言中(Java、C#等)，都是使用根搜索算法判定对象是否存活。算法的基本思路是:通过一系列名为"GC Roots"的对象作为起始点，从这些其实节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连(用图论的话来说就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。在Java语言里，可作为GC Roots的对象包括下面几种:<p>
虚拟机栈(栈帧中的本地变量表)中的引用的对象<p>
方法区中的类静态属性引用的对象<p>
方法区中的常量引用的对象<p>
本地方法栈中JNI(即一般说的Native方法)的引用的对象<p>
在JDK1.2之前引用的定义很传统:如果Reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。在JDK1.2之后，对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)，这四种引用强度一次逐渐减弱.<p>
>> 强引用:只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。<p>
>> 软引用:用来描述一些还有用但并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象裂锦回收范围之中并进行第二次回收，如果这次回收还是没有足够的内存才会抛出内存溢出异常。与引用队列(Reference Queue)配合使用.<p>
>> 弱引用: 也是藐视非必须对象的但比弱引用更弱一些，**被弱引用关联的对象只能生存到下一次垃圾收集发生之前**，当垃圾收集器工作时无论内存是否足够都会回收。与引用队列(Reference Queue)配合使用.<p>
>> 虚引用: 也称幽灵引用或者幻影引用，是最弱的一种引用关系。对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。设置这个引用的唯一目的就是希望对象被收集器回收时收到一个通知。与引用队列(Reference Queue)配合使用.<p>

>>> 任何一个对象的Finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。

* 回收方法区
> 永久代(方法区)的垃圾收集主要回收两部分:废弃常量和无用的类。废弃常量回收与Java堆中对象的回收类似。如果没有任意一个引用或基本类型值与其相等，在这时候如果发生内存回收而且必要的话这个常量就会被系统移出常量池。<p>
>> 判定一个类是否是无用的类:<p>
1、该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。<p>
2、加载该类的ClassLoader已经被回收<p>
3、该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法<p>
> 可以使用虚拟机参数查看类的加载和卸载信息。在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

#### 垃圾收集算法
* 标记-清楚算法
> 算法分为"标记"和"清除"两个阶段:首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。**这种算法存在几个缺点**<p>
>> 一个是效率问题，标记和清除过程的效率都不高<p>
>> 一个是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能导致当程序在需要分配较大内存时而导致无法找到足够的连续内存而不得不触发另外一次收集动作。

* 复制算法
> 算法思想是:将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了九江还活着的对象复制到另外一块上面，然后将已经使用过的内存空间一次清理掉。
>> 这种算法的优点:每次回收内存时不需要考虑内存碎片等复杂情况，只要移动堆顶指针按顺序分配内存即可，实现简单，运行高效。

>> 缺点: 内存利用率只有一半，代价太高。
> 现在商用VM都采用这种算法来回收新生代，IBM的专门研究表明新生代中的对象98%是朝生夕死的，所以不需要按照1：1的比例来划分内存空间，而是将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor，当回收是，将Eden和刚才使用过的Survivor中还存活的对象一次拷贝到另外一块Survivor空间上，最后清理Eden和刚才用过的Survivor空间。HotSpot VM默认的Eden和Survivor的大小比例是8：1：1，每次新生代容量占整个可用内存的90%，这样浪费的就比较少。如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来存活的对象，这些对象将直接通过分配担保机制进入来年代。

* 标记-整理算法
> 算法思想: 先标记所有存活的对象，而后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

* 分代收集算法
> 根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中每次收集的对象只有少量存辉那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率搞，没有额外的空间对它进行分配担保，就必须使用标记清理或标记整理算法来回收。

#### 垃圾收集器
> HotSpot VM包含的所有收集器:![HotSpot VM垃圾收集器](/doc/image/HotSpot_JVM_Garbage_Collection.png)
七种不同的分代收集器，连线之间的收集器可以搭配使用。

* Serial收集器(Serial 连续的、连载的)
> Serial收集器是最基本、历史最悠久的收集器，曾经(JDK1.3之前)是虚拟机新生代收集器的唯一选择。这是一个单线程收集器，但并不意味着它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在进行垃圾收集时，必须暂停其他所有的工作线程(Sun 将这件事称之为 Stop The World),直到收集结束。这项工作是由VM在后台自动发起和自动完成的。![Serial/Serial Old收集器运行示意图](/doc/image/Serial_Serial_old_garbage_collection.png)
相较于其他收集器:简单高效(与其他收集器的单线程相比)，对于限定单个CPU的环境来说，Serial收集器米有线程交互的开销，效率相对较高。是虚拟机运行在**Client**模式下的默认新生代收集器。

* ParNew收集器
> ParNew 收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数(如:-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等)、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，实现这两种收集器也共用了相当多的代码。![ParNew/Serial Old收集器运行示意图](/doc/image/ParNew_Serial_old.png)
是虚拟机运行在**Server**模式下的首选新生代收集器，其中一个与性能无关但很重要的原因是：除了Serial收集器之外，目前只有它能与CMS(Concurrent Mark Sweep)收集器配合工作。CMS作为一款并发老年代收集器，不能与新生代收集器Parallel Scavenge配合工作，只能使用ParNew或Serial作为新生代收集器。ParNew收集器也是使用-XX:+useConCMarkSweepGC选项后默认的新生代收集器，也可以使用-XX:UseParNewGC强制指定。ParNew收集器在单线程环境下并不比Serial收集器优越，只有当线程到一定程度后才能体现出优越性能，当然线程过多情况下，线程的开销也会增大。-XX:ParallelGCThread参数可以用来限制垃圾收集的线程数。
>>> 在虚拟机收集器的上下文预警中并发与并行的解释为:<p>
并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<p>
并发(Concurrent): 指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，用户程序继续运行，而垃圾收集程序运行于另外一个CPU上。

* Parallel Scavenge收集器
> 是一个新生代收集器，使用复制算法的并行多线程收集器，被称为"吞吐量优先"收集器。
>> Parallel Scavenge收集器与其他的收集器的关注点不同，CMS等收集器的关注点尽可能的缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控的吞吐量(Throughput)【CPU用于运行用户代码的时间与CPU消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)】。<p>
停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快完成程序的运算任务，主要是和在后台运算而不需要太多交互的任务。<p>
Paraller Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的-XX:GCTimeTatio参数。
>>> MaxGCPauseMillis参数是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。设定这个值并不能使得系统的垃圾收集速度更快，而是以牺牲吞吐量和新生代空间来换取GC停顿时间缩短：系统将新生代调小，导致垃圾收集变得更频繁，吞吐量更小。<p>
GCTimeRatio参数是大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如：把参数设置为19，那允许的最大GC时间占总时间的5%(1/(1+19)),默认值为99，就是允许最大1%(1/(1+99))的垃圾收集时间。<p>
-XX:+UseAdaptiveSizePolicy参数，当参数打开之后，就不需要手工指定新生代大小(-Xmn)、Eden与Survivor区的比例(-XX:SurvivorRatio)、晋升老年带对象年龄(-XX:PretenureSizeThreshold)等细节参数，VM或根据当前系统的运行情况收集性能监控信息，动态调节这些参数已提供最适合的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略(GC Ergonomics).
>>>>>需要说明的是Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集，并没有直接使用Serial Old收集器，但这个PS MarkSweep收集器示意Serial Old收集器为模板设计的，与Serial Old的实现非常接近，所以基本都是介绍Serial Old而不重新介绍PSMarkSweep收集器。

* Serial Old收集器
> 是Serial收集器的老年代版本，也是一个单线程收集器，使用"标记-整理"算法。同Serial一样主要也是在Client模式下的虚拟机使用。如果在Server模式下还有两大用途：一是在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一个就是作为CMS收集器的后背元，在并发收集发生Concurrent Mode Failure的时候使用。
![Serial Olds收集器的工作过程](/doc/image/Serial_Serial_old_garbage_collection.png)

* Parallel Old收集器
> 是Parallel Scavenge收集器的老年代版本,使用"标记-整理"算法。在JDK1.6中才开始提供。![Parallel Old收集器工作过程示意图](/doc/image/ParNew_Serial_old.png)

* CMS收集器(Concurrent Mark Sweep)
> 是一种以获取最短回收停顿时间为目标的收集器。响应速度在对用户系统上是非常重要的。CMS收集器是基于"标记-清楚"算法实现的，运作过程相对于其他几种收集器来说比价复杂，分为以下4个步骤:
>> 初始标记(CMS initial mark)<p>
并发标记(CMS concurrent mark)<p>
重新标记(CMS remark)<p>
并发清除(CMS concurrent sweep)
> 其中初始标记和重新标记这两个步骤仍然需要"Stop The World“。初始标记静静只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修改并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍微长一些，但远比并发标记时间短。<p>
在CMS收集器中并发标记和并发清除耗时最长，且在这两个阶段中是与用户线程并发执行的，虽然初始标记和重新表示并行执行的但耗时很短，所有从总体上来说CMS收集器的内存回收过程与用户线程是一起并发执行的。![CMS收集器工作示意图](/doc/image/ConcurrentMarkSweep.png)
>> CMS收集器是一款优秀的收集器：并发收集(非并发部分耗时很少)、低停顿。
>> 但是CMS收集器也存在以下几个缺点
>>>> CMS收集器对CPU资源非常敏感：面向并发设计的程序对CPU资源都比较敏感。并发时虽然不会导致用户线程停顿，但会占用一部分线程(或CPU资源)而导致应用程序变慢，总吞吐量变低。CMS默认启动回收线程数是(CPU数量+3)/4，也就是当CPU在4个以上，并发垃圾收集线程最大占用不超过25%，否则会占用大量线程资源。基于这种资源占用情况，VM提供了一种称为"增量式并发收集器"(Incremental Concurrent Mark Sweep i-CMS)的CMS收集器变种，就是在并发表及和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，速度下降没那么明显，但目前版本中i-CMS已经被声明为"deprecated"。<p>
CMS收集器无法处理浮动垃圾(Floating Garbage):由于CMS鬓发清理阶段用户线程还在运行自然还会有新的垃圾不断产生，此时CMS收集器已经无法清理掉只能留待下一次回收，这一部分垃圾就称为"浮动垃圾"。在CMS收集器中老年代使用了68%的空间后会被激活，如果应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数以获取更好的性能。如果CMS运行期间预留的内存无法满足程序需要，就会出现一次"Concurrent Mode Failure"失败，这时候VM虚拟机将启动预备元:临时启用Serial Old收集器重新进行老年代垃圾收集，这样停顿时间就很长了。<p>
CMS是一款基于"标记-清楚"算法实现的收集器。这种算法会产生内存碎片，导致明明内存足够却分配失败而提前出发Full GC。CMS收集器提供了一个-XX:YseCompactFullCollection开关参数，用于在Full GC后免费附送一个碎片整理过程，内存整理过程是无法并发的。VM还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction用于设置在执行多少次不压缩的Full GC后，跟踪来一次带压缩的。

* G1收集器
> G1收集器是基于"标记-整理"算法实现的收集器，也就是不会产生内存碎片，这对于长时间运行的应用系统来说非常重要；可以精确控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内消耗在垃圾收集上的时间不超过N毫秒，这几乎已经是实时Java(RTSJ)的垃圾收集器的特征。<p>
G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收。G1收集器讲真个Java堆(包括新生代、老年代)划分为多个大小固定的独立区域(Region),并跟踪这些区域里的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间优先回收垃圾最多的区域(这就是Garbage First名称的来由)。区域划分与优先级保证了G1在有限的时间内获得最高的收集效率。
* 垃圾收集器参数总结

|参数| 描述|
|-----|-----|
|UseSerialGC|VM运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收|
|UseParNewGC|打开此开关后，使用ParNew+ Serial Old的收集器组合进行内存回收|
|UseConcMarkSweepGC|打开此开关后，使用ParNew + CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Model Failure失败后的后背收集器使用|
|UseParallelGC|VM运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old(PS MarkSweep)的收集器组合进行内存回收|
|UseParallelOldGC|打开此开关后使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收|
|SurvivorRatio|新生代中Eden区域与Survivor区域的容量比值，默认值为8，代表Eden：Survivor=8：1|
|PretenureSizeThreshold|直接晋升到老年代对象的大小，设置这个参数后，大于则各参数的对象将直接在老年代分配|
|maxTenuribgThreshold|晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就+1，当超过这个参数值时就进入老年代|
|UseAdaptiveSizePolicy|动态调整Java堆中各个区域的大小以及进入老年代的年龄|
|HandlePromotionFailure|是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况|
|ParallelGCThreads|设置并行GC时进行内存回收的线程数|
|GCTimeRatio|GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效|
|MaxGCPauseMillis|设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效|
|CMSInitiatingOccupancyFraction|设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效|
|UseCMSCompactAtFullCollection|设置CMS收集器在完成垃圾收集后是否需要进行一次内存碎片整理。仅在使用CMS垃圾收集器时生效|
|CMSFullGCsBeforeCompaction|设置CMS收集器在进行若干次垃圾收集后在启动一次内存碎片整理。仅在使用CMS垃圾收集器时生效|
|PrintTenuringDistribution|检查每次minor GC后新的存活周期的阈值|

#### 内存分配和回收策略
> 对象的内存分配，从大方向上讲是在堆上分配(也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配)，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓存，将按线程优先在TLAB(ThreadLocalAllocBuffer)上分配.少数情况下也可能会直接分配在老年代中，分配规则并不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。<p>

* 对象优先在Eden分配
> 大多数情况下，对象都是在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。
>> 验证时需要设置VM参数: -XX:+PrintGCDetails 打印垃圾收集是的内存回收日志 -Xms -Xmx 最小 最大堆内存 -Xmn 新生代内存 -XX:SurvivorRatio=8 Eden和Survivor比例

* 大对象直接进入老年代
> 需要连续内存空间的Java对象，VM提供了-XX:PretenureSizeThreshold参数设置对象大于这个参数后直接在老年代分配。避免新生代的Eden和Survivor之间发生大量内存拷贝。
>> PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效(新生代收集器)，Parallel Scavenge收集器不认识上面这个参数。如果需要使用该参数可以考虑使用ParNew+CMS组合。

* 长期存活的对象将进入老年代
> VM给每个对象定义了一个对象年龄计数器，如果对象在Eden区域分配空间并经历过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移动到Survivor空间中并将对象年龄+1，对象在Survivor中没经历过一次Minor GC，对象年龄就+1当增加到一定程度(默认15)时，就会被移动到老年代中。这个年龄阈值(yu)可以通过参数:-XX:MaxTenuringThreshold=1来设置。

* 动态对象年龄判定
> 如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。

* 空间分配担保
> 在发生minor GC时，VM会检测之前每次晋升到老年代的**平均大小**是否大于老年代的剩余空间大小，如果大于则改为直接进行一次Full GC。如果小于则查看HandlePromotionFailure设置是否允许担保失败，如果允许则只会进行Minor GC；否则也好进行一次Full GC。<p>