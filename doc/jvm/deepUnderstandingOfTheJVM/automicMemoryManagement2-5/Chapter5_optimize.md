## 调优案例分析

* 高性能硬件上的程序部署策略
> 在高性能硬件上部署程序，目前主要有两种放肆:
>> 通过64位JDK来使用大内存<p>
使用若干个32位VM建立逻辑集群来利用硬件资源

> 使用64位JDK管理大内存需要面临以下问题
>> 内存回收导致的长时间停顿<p>
现阶段64位JDK的性能测试结果普遍低于32位JDK<p>
需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照(因为要产生很大GB乃至更大的dump文件)，即使产生了快照也无法进行分析<p>
相同程序在64位JDK中消耗的内存一般比32位JDK大，这是由指针膨胀及数据类型对齐补白等因素导致的。

> 使用逻辑集群的方式来部署程序可能会遇到以下问题:
>> 尽量避免节点竞争全局的资源，最典型的的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话(尤其是并发写操作容易出现问题),很容易导致IO异常<p>
很难最高效率的利用某些资源，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI，但这有一定的复杂性并且可能带来额外的性能代价。<p>
各个节点仍然不可避免地收到32位内存限制，32位的Windows平台中每个进程只能使用2GB内存，考虑到堆以外的开销，一般只能开到1.5GB.在一些Linux、Unix(如Solaris)中，可以提升到3GB乃至接近4GB，但32位中任然受最高4GB(2^32)内存的限制<p>
大量使用本地缓存(如大量使用HashMap作为K/V缓存)的应用，在逻辑群中会造成大量内存浪费，每个节点的缓存可以改为共享集中式缓存。

* 集群间同步导致的内存溢出
> 频繁的数据同步导致(当网络抖动导致同步发送的数据包堆积)
* 堆外内存导致的溢出错误(直接内存)
> 堆外内存未释放。除了Java堆和永久代，其他区域还会占用较多的内存，而所有内存总和会受到操作系统进程最大内存限制:
>> Direct Memory:可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或OutOfMemoryError:Direct buffer memory.<p>
线程堆栈:可通过-Xss调整大小，内存不足时抛出StackOverflowError(纵向无法分配，即无法分配新的栈帧，栈深度超过设定1000-2000)或OutOfMemoryError:unable to create new native thread(横向无法分配，即无法建立新的线程，内存连续区域不足以分配线程所需)。<p>
Socket缓存区:每个Socket连接都有Receive和Send两个缓存区。分别占用37KB和25KB的内存，链接多的话这块内存占用也比较可观。如果无法分配则可能会抛出IOException: Too many open files异常<p>
JNI代码:如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。<p>
VM和GC:VM和GC的代码执行也需要消耗一定内存。

* 外部命令导致系统缓慢
> Runtime.getRuntime().exec()调用获取部分系统信息，这个调用时非常消耗资源的。Java VM执行这个命令的过程是:首先克隆一个和当前VM拥有一样环境变量的进程，再用这个新色进程去执行外部命令，最后再退出这个进程。频繁的创建进程，系统CPU、内存都会消耗巨大。

* JVM进程崩溃
> 调用外部接口超时后导致堆积大量Socket连接请求，导致进程自动关闭。