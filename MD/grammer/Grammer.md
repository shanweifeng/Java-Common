# [基本语法](https://www.cnblogs.com/chenglc/p/6922834.html) [跳转首页](https://github.com/shanweifeng/Java-Common#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE)

###关键字

- 关键字总览 

|范围|关键字|
|----|------|
|访问控制|	private	protected	public|						
|类、方法和变量修饰符|	abstract	class	extends	final	implements	interface	native	new	static strictfp	synchronized	transient	volatile	enum	|	
|程序控制|	break	continue	return	do	while	if	else	for	instanceof switch	case	default	assert		|			
|错误处理|	try	catch	throw	throws	finally|				
|包相关|	import	package	|						
|基本类型|	boolean	byte	char	double	float	int	long	short	null TRUE	FALSE				|			
|变量引用|	super	this	void|						
|保留字|	goto	const|							

- 详细解释

1. 访问控制(3个)<p>
_关键字是可以应用于类、方法或字段(在类中声明的变量)的访问控制修饰符.所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员_<p> 
*_private_* : 一种访问控制方式：私有模式。
只能在声明private(内部)类、方法、或字段的类中引用这些类、方法或字段。在类的外部或对于子类而言，它们是不可见的。<p>
*_protected_* : 一种访问控制方式：保护模式。
可以在声明protected类、方法、或字段的类、同一个包中的其他任何类以及任何子类(无论子类是在哪个包中声明的)中引用这些类、方法或字段。<p>
*_public_* : 一种访问控制方式：共有模式。
可能只会在其他任何类或包中引用public类、方法或字段
  
2. 类、方法和变量修饰符(14个)<p>
*_abstract_* : 声明抽象 可以修饰类或方法。abstract类可以扩展(增加子类)，但不能直接实例化。abstract方法不在声明它的类中实现，但必须在某个子类中重写。采用abstract方法的类本来就是抽象类，并且必须声明为abstract。<p>
*_class_* : 类 用来声明新的Java类，该类是相关变量和/或方法的集合。类是面向对象的程序设计方法的基本构造单位。类通常代表某种实际实体、是对象的模板，每个对象都是类的一个实例。可以使用new关键字创建对象、newInstance、clone、反序列化<p>
*_extends_* : 继承、扩展 用在class或interface声明中，用于指示所声明的类或接口是其名称后跟有extends关键字的类或接口的子类。子类继承父类的所有public和protected变量和方法。子类可以重写父类的任何非final方法(私有的不能重写)。一个类只能扩展一个其他类。<p>
*_final_* : 最终、不可变 应用于类指示类不能扩展，应用于方法指示子类中不能重写此方法。应用于变量指示值不可变。一个类不能同时是abstract又是final，abstract意味着必须扩展，final意味着不能扩展类。一个方法不能同时是abstract又是final，abstract意味着方法必须重写，final意味着不能重写方法。<p>
*_implements_* : 实现 在class中声明使用，以指示所声明的类提供了在implements关键字后面的名称所指定的接口中所声明的所有方法的实现。类必须提供在接口中声明的所有方法的实现。一个类可以实现多个接口。<p>
*_interface_* : 接口 用来声明新的Java接口，接口是方法的集合。实现了接口的任何类都必须提供在该接口中的所有方法的实现。一个类可以有多个接口。<p>
*_native_* : 本地 可以应用于方法，以指示该方法是用Java以外的语言实现的。<p>
*_new_* : 创建 用于创建类的新实例。关键字后面的参数必须是类名，并且类名的后面必须是一组构造方法参数，参数集合必须与类的构造方法签名匹配。<p>
*_static_* : 静态 可以应用于内部类、方法、或字段。意味着应用它的实体在声明该实体的类的任何特定实例外部可用(static声明的可以直接使用类调用)，可以被其他类实例化和引用，在类的所有实例中只存在一次。<p>
*_strictfp_* : 严格、精准，精确浮点。<p>可以将一个雷、接口、方法声明为strictfp，但是不允许对接口中的方法以及构造函数声明strictfp关键字<p>
*_synchronized_* : 线程、同步 可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。可防止代码的关键代码段一次被多个线程执行。<p>如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。<p>如果用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。<p>如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。<p>
*_transient_* : 短暂 可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。当一个对象呗串行化(序列化)时，transient型变量的值不包括在串行化的表示中，非transient型的变量是被包括进去的。<p>
*_volatile_* : 易失 用于表示可以被多个线程异步修改的成员变量。保证顺序性和可见性，但是不保证原子性。在多线程中必须注意。<p>
*_enum_* : 枚举 定义有限个数的关键字。<p>
3. 程序控制(13个)<p>
*_break_* : 跳出 中断，提前退出循环或结束case块，如果循环中存在标记，也可以退出到指定标记的下一个语句。<p>
*_continue_* : 继续，跳转到下一个循环，如果循环中存在标记，也可以跳转到指定标记的循环处继续循环。<p>
*_return_* : 导致方法返回到调用它的方法，从而传递与返回方法的返回类型匹配的值。如果方法方法具有非void的返回类型，return语句必须具有相同或兼容类型的参数。<p>
*_do_* : 运行，用于指定一个在每次迭代结束时检查其条件的循环，循环体至少执行一次，表达式后面必须有分号<p>
*_while_* : 循环，指定一个只要条件为真就会重复的循环<p>
*_if_* : 指示有条件的执行代码块，条件的计算结果必须是Boolean类型，如果有可选的else子句，该子句包含条件为false时将执行代码。<p>
*_else_* : 总是在if-else语句中与if关键字结合使用。else子句是可选的，如果if条件为 false，则执行该子句。<p>
*_for_* : 用于指定一个在每次迭代结束前检查其条件的循环，语句形式为for(initialize; condition; increment)<p>
*_instanceof_* : 用来确定对象所属的类<p>
*_switch_* : 用于基于某个表达式选择执行多个代码块中的某一个，计算结果必须等于byte char short int<p>
*_case_* : 用来标记switch语句中的每个分支<p>
*_default_* : switch默认分支<p>
*_assert_* : 断言<p>

4. 错误处理(5个)<p>
*_try_# : 用于包含肯能引发异常的语句块，每个try块都必须跟一个catch或finally子句。如果某个特定异常类未被任何catch子句处理，该异常将沿着调用栈递归的传播到下一个封闭try块。如果任何封闭try块都未捕获到异常，Java解释器将退出，并显示错误消息和堆栈跟踪信息。<p>
*_catch_# : 用来在try-catch或try-cache-finally语句中定义异常处理块，处理语句必须在{}中间，如果某个特定异常类未被任何catch子句处理，该异常将沿着调用栈递归的传播到下一个封闭try块。如果任何封闭try块都未捕获到异常，Java解释器将退出，并显示错误消息和堆栈跟踪信息。<p>
*_throw_# : 用于引发异常。将java.lang.Throwable作为参数。Throwable在调用栈中向上传播，直到被适当的catch块捕获。引发RuntimeException异常的任何方法还必须在方发声明中使用throws修饰符来声明它引发的异常。<p>
*_throws_# : 可以应用于方法，以便指出方法引发了特定类型的异常，将java.lang.Throwable作为参数。Throwable在调用栈中向上传播，直到被适当的catch块捕获。引发RuntimeException异常的任何方法还必须在方发声明中使用throws修饰符来声明它引发的异常。<p>
*_finally_# :  try块或catch块结束后必定执行的代码，如果finally中出现return关键字则try块或catch块中的返回值不起作用。<p>

5. 包相关(2个)<p>
*_import_* : 使一个包中的一个或所有类在当前Java源文件中可见。可以不使用完全限定的类名来引用导入的类。当多个包包含同名的类时，许多Java程序员只使用特定的import语句(没有"*")来避免不确定性。<p>
*_package_* : 关键字指定Java原文件中声明的类所驻留的Java包，(如果出现)必须是Java源文件中第一个非注释性文本。

6. 基本类型(11个)<p>
*_boolean_* : 布尔型 。是Java原始类型，变量的值可以使true或false,不能与数字类型进行转换，包含boolean操作数的表达式只能包含boolean操作数。Boolean类是boolean原始类型的包装对象(理论上占1bit，1/8字节实际按1byte处理)<p>
*_byte_* : 字节型。是Java原始类型，可存储在[-128 ~ 127]范围以内的整数值。Byte类是byte原始类型的包装对象。如果使用byte需要强制指定数据类型，Java中所有整数默认都是int值<p>
*_char_* : 字符型。是Java原始类型，可以存储一个Unicode字符。可以使用下列char常量：\b - 空格,\f - 换页,\n - 换行,\r - 回车,\t - 水平制表符,\' - 单引号,\" - 双引号,\\ - 反斜杠,\xxx - 采用xxx编码的Latin-1字符。\x和\xx均为合法形式，但可能引起混淆。\uxxxx -采用十六进制xxxx的Unicode字符。Character类是char原始类型的包装对象，没有符号，包含一些可用来处理char变量的static方法，如isDigit()、isLetter()、isWhitespace()和toUpperCase()。占用两个字节<p>
*_double_* : 双精度 Java原始类型，可以存储双精度浮点值。由于浮点数据类型是实际数值的近似值，因此一般不要对浮点数值进行是否相等比较。Java中默认的浮点数值为双精度,Double类是double原始类型的包装类型，占用8个字节<p>
*_float_* : 浮点 Java原始类型，可以存储单精度浮点值。由于浮点数据类型是实际数值的近似值，因此一般不要对浮点数值进行是否相等比较。单精度浮点值需要强制指定。占用4个字节。<p>
*_int_* : 整型 Java原始类型，存储[-2^31 ~ 2^31-1]范围的值。Integer类是int原始类型的包装类。占用4个字节<p>
*_long_* : 长整型 Java原始类型，可以存储64位的带符号整数[-2^63 ~ 2^63-1]范围的值，Long类是long原始类型的包装类，需要强制指定类型，占用8个字节。<p>
*_short_* : 短整型 Havana原始类型，可以存储[-2^15 ~ 2^15-1]范围的值，Short类是short原始类型的包装类，需要强制指定类型。占用2个字节<p>
*_null_* : 空 Java保留字，表示无值，将null赋值给非原始变量相当于释放该变量先前所引用的对象，不能将null赋值给原始类型。<p>
*_true_* : 真 表示Boolean变量的两个合法值中的一个<p>
*_false_* : 假 表示Boolean变量的两个合法值中的一个<p>
7. 变量引用(3个)<p>
*_super_* : 父类 超类，用于引用使用该关键字的超类。作为独立语句出现的super表示调用超类的构造方法。<p>super.<methodName>()表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便制定应当调用在超类中的该方法。<p>
*_this_* : 本类，用于引用当前实例。当引用可能不明确时，是可以使用this关键字来引用当前实例。<p>
*_void_* : 无返回值，表示null类型。可以用作方法的返回类型，以指示该方法不返回值。
8. 保留字(2个)<p>
_所有的关键字都是小写的_<p>
*_goto_* : 跳转 保留关键字，但无任何作用。结构化程序设计完全不需要goto语句即可完成各种流程，而goto语句的使用往往会使程序的可读性降低，所以Java不允许goto跳转。<p>
*_const_* : 静态 保留字，是一个类型修饰符，使用const声明的对象不能更新。与final某些类似。<p>
*_native_* : 本地 Java不是完美的，Java的不足除了体现在运行速度上要比传统的C++慢许多之外，Java无法直接访问到操作系统底层(如硬件系统)，为此Java使用native方法来扩展Java程序的功能。
 **_Java将native方法比作Java程序同C程序的接口，其实现步骤_**：
    1、在Java中声明native()方法，然后编译；
    2、用javah产生一个.h文件；
    3、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件(注意其中又包含了JDK带的jni.h文件)；
    4、将第三步的.cpp文件编译成动态链接库文件；
    5、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。

  